{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"XLOFT","text":"<p>(XLOFT) X-Library of tools.</p> <p>Modules exported by this package:</p> <ul> <li><code>namedtuple</code>: Class imitates the behavior of the named tuple.</li> <li><code>human</code> - A collection of instruments for converting data to format is convenient for humans.</li> <li><code>quantum</code> - A set of tools for quantum calculations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv add xloft\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"md_pages/errors/","title":"Errors","text":"<p>XLOT Exceptions.</p>"},{"location":"md_pages/errors/#xloft.errors.AttributeCannotBeDelete","title":"<code>AttributeCannotBeDelete</code>","text":"<p>               Bases: <code>XLOTException</code></p> <p>Exception is raised if the attribute cannot be delete.</p> Source code in <code>src\\xloft\\errors.py</code> <pre><code>class AttributeCannotBeDelete(XLOTException):\n    \"\"\"Exception is raised if the attribute cannot be delete.\"\"\"\n\n    def __init__(self, attribute_name: str) -&gt; None:  # noqa: D107\n        self.message = f\"The attribute `{attribute_name}` cannot be delete!\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"md_pages/errors/#xloft.errors.AttributeDoesNotSetValue","title":"<code>AttributeDoesNotSetValue</code>","text":"<p>               Bases: <code>XLOTException</code></p> <p>Exception is raised if the attribute does not setting value.</p> Source code in <code>src\\xloft\\errors.py</code> <pre><code>class AttributeDoesNotSetValue(XLOTException):\n    \"\"\"Exception is raised if the attribute does not setting value.\"\"\"\n\n    def __init__(self, attribute_name: str) -&gt; None:  # noqa: D107\n        self.message = f\"The attribute `{attribute_name}` does not setting value!\"\n        super().__init__(self.message)\n</code></pre>"},{"location":"md_pages/errors/#xloft.errors.XLOTException","title":"<code>XLOTException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Root Custom Exception.</p> Source code in <code>src\\xloft\\errors.py</code> <pre><code>class XLOTException(Exception):\n    \"\"\"Root Custom Exception.\"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:  # type: ignore[no-untyped-def]# noqa: D107\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"md_pages/human/","title":"Human","text":"<p>A collection of instruments for converting data to format is convenient for humans.</p> <p>The module contains the following functions:</p> <ul> <li><code>to_human_size(size)</code> - Returns a humanized string: 200 bytes | 1 KB | 1.5 MB etc.</li> </ul>"},{"location":"md_pages/human/#xloft.human.clean_cache_human_size","title":"<code>clean_cache_human_size()</code>","text":"<p>Reset of variable _cach_human_size.</p> Source code in <code>src\\xloft\\human.py</code> <pre><code>def clean_cache_human_size() -&gt; None:\n    \"\"\"Reset of variable _cach_human_size.\"\"\"\n    global _cache_human_size  # noqa: PLW0603\n    _cache_human_size = {}\n</code></pre>"},{"location":"md_pages/human/#xloft.human.get_cache_human_size","title":"<code>get_cache_human_size()</code>","text":"<p>Get a copy of variable _cach_human_size.</p> <p>Hint: To tests.</p> Source code in <code>src\\xloft\\human.py</code> <pre><code>def get_cache_human_size() -&gt; dict[int, str]:\n    \"\"\"Get a copy of variable _cach_human_size.\n\n    Hint: To tests.\n    \"\"\"\n    return _cache_human_size.copy()\n</code></pre>"},{"location":"md_pages/human/#xloft.human.to_human_size","title":"<code>to_human_size(n_bytes)</code>","text":"<p>Convert number of bytes to readable format.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import to_human_size\n&gt;&gt;&gt; to_human_size(200)\n200 bytes\n&gt;&gt;&gt; to_human_size(1048576)\n1 MB\n&gt;&gt;&gt; to_human_size(1048575)\n1023.999 KB\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>n_bytes</code> <code>int</code> <p>The number of bytes.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Returns a humanized string: 200 bytes | 1 KB | 1.5 MB etc.</p> Source code in <code>src\\xloft\\human.py</code> <pre><code>def to_human_size(n_bytes: int) -&gt; str:\n    \"\"\"Convert number of bytes to readable format.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import to_human_size\n        &gt;&gt;&gt; to_human_size(200)\n        200 bytes\n        &gt;&gt;&gt; to_human_size(1048576)\n        1 MB\n        &gt;&gt;&gt; to_human_size(1048575)\n        1023.999 KB\n\n    Args:\n        n_bytes: The number of bytes.\n\n    Returns:\n        Returns a humanized string: 200 bytes | 1 KB | 1.5 MB etc.\n    \"\"\"\n    result: str | None = _cache_human_size.get(n_bytes)\n    if result is not None:\n        return result\n    idx: int = math.floor(math.log(n_bytes) / math.log(1024))\n    ndigits: int = [0, 3, 6, 9, 12][idx]\n    human_size: int | float = n_bytes if n_bytes &lt; 1024 else abs(round(n_bytes / pow(1024, idx), ndigits))\n    order = [\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"][idx]\n    if math.modf(human_size)[0] == 0.0:\n        human_size = int(human_size)\n    result = f\"{human_size} {order}\"\n    _cache_human_size[n_bytes] = result\n    return result\n</code></pre>"},{"location":"md_pages/installation/","title":"Installation","text":"<pre><code>uv add xloft\n</code></pre>"},{"location":"md_pages/namedtuple/","title":"NamedTuple","text":"<p>This module contains the implementation of the <code>NamedTuple</code> class.</p> <p><code>NamedTuple</code> class imitates the behavior of the named tuple.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\", _id=\"507c7f79bcf86cd7994f6c0e\")\n&gt;&gt;&gt; nt.x\n10\n&gt;&gt;&gt; nt.y\nHello\n&gt;&gt;&gt; nt._id\n507c7f79bcf86cd7994f6c0e\n&gt;&gt;&gt; nt.z\nKeyError\n&gt;&gt;&gt; len(nt)\n3\n&gt;&gt;&gt; nt.keys()\n[\"x\", \"y\", \"_id\"]\n&gt;&gt;&gt; nt.values()\n[10, \"Hello\", \"507c7f79bcf86cd7994f6c0e\"]\n&gt;&gt;&gt; nt.has_key(\"x\")\nTrue\n&gt;&gt;&gt; nt.has_key(\"z\")\nFalse\n&gt;&gt;&gt; nt.has_value(10)\nTrue\n&gt;&gt;&gt; nt.has_value([1, 2, 3])\nFalse\n&gt;&gt;&gt; nt.get(\"x\")\n10\n&gt;&gt;&gt; nt.get(\"z\")\nNone\n&gt;&gt;&gt; d = nt.to_dict()\n&gt;&gt;&gt; d[\"x\"]\n10\n&gt;&gt;&gt; for key, val in nt.items():\n...     print(f\"Key: {key}, Value: {val}\")\n\"Key: x, Value: 10\"\n\"Key: y, Value: Hello\"\n\"Key: _id, value: 507c7f79bcf86cd7994f6c0e\"\n&gt;&gt;&gt; nt.update(\"x\", 20)\n&gt;&gt;&gt; nt.x\n20\n&gt;&gt;&gt; nt.update(\"z\", [1, 2, 3])\nKeyError\n&gt;&gt;&gt; nt[\"z\"] = [1, 2, 3]\nTypeError\n&gt;&gt;&gt; nt.x = 20\nError: AttributeDoesNotSetValue\n&gt;&gt;&gt; del nt.x\nError: AttributeCannotBeDelete\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple","title":"<code>NamedTuple</code>","text":"<p>This class imitates the behavior of the named tuple.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>class NamedTuple:\n    \"\"\"This class imitates the behavior of the _named tuple_.\"\"\"\n\n    def __init__(self, **kwargs: dict[str, Any]) -&gt; None:  # noqa: D107\n        self.__dict__[\"_jWjSaNy1RbtQinsN_keys\"] = []\n        for name, value in kwargs.items():\n            self.__dict__[name] = value\n            self._jWjSaNy1RbtQinsN_keys.append(name)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get the number of elements.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; len(nt)\n            2\n\n        Returns:\n            The number of elements in the tuple.\n        \"\"\"\n        return len(self._jWjSaNy1RbtQinsN_keys)\n\n    def __getattr__(self, name: str) -&gt; Any:\n        \"\"\"Getter.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; nt.x\n            10\n\n        Args:\n            name: Key name.\n\n        Returns:\n            Value of key.\n        \"\"\"\n        return self.__dict__[name]\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:\n        \"\"\"Blocked Setter.\"\"\"\n        raise AttributeDoesNotSetValue(name)\n\n    def __delattr__(self, name: str) -&gt; None:\n        \"\"\"Blocked Deleter.\"\"\"\n        raise AttributeCannotBeDelete(name)\n\n    def get(self, key: str) -&gt; Any:\n        \"\"\"Return the value for key if key is in the dictionary, else `None`.\n\n        Args:\n            key: Key name.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; nt.get(\"x\")\n            10\n\n        Returns:\n            Value of key.\n        \"\"\"\n        value = self.__dict__.get(key)\n        if value is not None:\n            return value\n        return None\n\n    def update(self, key: str, value: Any) -&gt; None:\n        \"\"\"Update a value of key.\n\n        Attention: This is an uncharacteristic action for the type `tuple`.\n\n        Args:\n            key: Key name.\n            value: Value of key.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; nt.update(\"x\", 20)\n            &gt;&gt;&gt; nt.x\n            20\n\n        Returns:\n            None\n        \"\"\"\n        keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n        if key not in keys:\n            err_msg = f\"The key `{key}` is missing!\"\n            raise KeyError(err_msg)\n        self.__dict__[key] = value\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert to the dictionary.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; d = nt.to_dict()\n            &gt;&gt;&gt; d[\"x\"]\n            10\n\n        Returns:\n            Dictionary with keys and values of the tuple.\n        \"\"\"\n        attrs: dict[str, Any] = self.__dict__\n        keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n        return {key: attrs[key] for key in keys}\n\n    def items(self) -&gt; list[tuple[str, Any]]:\n        \"\"\"Return a set-like object providing a view on the NamedTuple's items.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; for key, val in nt.items():\n            ...     print(f\"Key: {key}, Value: {val}\")\n            \"Key: x, Value: 10\"\n            \"Key: y, Value: Hello\"\n\n        Returns:\n            list[tuple[str, Any]]\n        \"\"\"\n        attrs: dict[str, Any] = self.__dict__\n        keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n        return [(key, attrs[key]) for key in keys]\n\n    def keys(self) -&gt; list[str]:\n        \"\"\"Get a list of keys.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; nt.keys()\n            [\"x\", \"y\"]\n\n        Returns:\n            List of keys.\n        \"\"\"\n        return self._jWjSaNy1RbtQinsN_keys\n\n    def values(self) -&gt; list[Any]:\n        \"\"\"Get a list of values.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; nt.values()\n            [10, \"Hello\"]\n\n        Returns:\n            List of values.\n        \"\"\"\n        attrs: dict[str, Any] = self.__dict__\n        keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n        return [attrs[key] for key in keys]\n\n    def has_key(self, key: str) -&gt; bool:\n        \"\"\"Returns True if the key exists, otherwise False.\n\n        Args:\n            key: Key name.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; nt.has_key(\"x\")\n            True\n\n        Returns:\n            True if the key exists, otherwise False.\n        \"\"\"\n        keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n        return key in keys\n\n    def has_value(self, value: Any) -&gt; bool:\n        \"\"\"Returns True if the value exists, otherwise False.\n\n        Args:\n            value: Value of key.\n\n        Examples:\n            &gt;&gt;&gt; from xloft import NamedTuple\n            &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n            &gt;&gt;&gt; nt.has_value(10)\n            True\n\n        Returns:\n            True if the value exists, otherwise False.\n        \"\"\"\n        values = self.values()\n        return value in values\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.__delattr__","title":"<code>__delattr__(name)</code>","text":"<p>Blocked Deleter.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def __delattr__(self, name: str) -&gt; None:\n    \"\"\"Blocked Deleter.\"\"\"\n    raise AttributeCannotBeDelete(name)\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Getter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; nt.x\n10\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Key name.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Value of key.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Any:\n    \"\"\"Getter.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; nt.x\n        10\n\n    Args:\n        name: Key name.\n\n    Returns:\n        Value of key.\n    \"\"\"\n    return self.__dict__[name]\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; len(nt)\n2\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements in the tuple.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Get the number of elements.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; len(nt)\n        2\n\n    Returns:\n        The number of elements in the tuple.\n    \"\"\"\n    return len(self._jWjSaNy1RbtQinsN_keys)\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Blocked Setter.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n    \"\"\"Blocked Setter.\"\"\"\n    raise AttributeDoesNotSetValue(name)\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.get","title":"<code>get(key)</code>","text":"<p>Return the value for key if key is in the dictionary, else <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; nt.get(\"x\")\n10\n</code></pre> <p>Returns:</p> Type Description <code>Any</code> <p>Value of key.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Return the value for key if key is in the dictionary, else `None`.\n\n    Args:\n        key: Key name.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; nt.get(\"x\")\n        10\n\n    Returns:\n        Value of key.\n    \"\"\"\n    value = self.__dict__.get(key)\n    if value is not None:\n        return value\n    return None\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.has_key","title":"<code>has_key(key)</code>","text":"<p>Returns True if the key exists, otherwise False.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; nt.has_key(\"x\")\nTrue\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if the key exists, otherwise False.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def has_key(self, key: str) -&gt; bool:\n    \"\"\"Returns True if the key exists, otherwise False.\n\n    Args:\n        key: Key name.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; nt.has_key(\"x\")\n        True\n\n    Returns:\n        True if the key exists, otherwise False.\n    \"\"\"\n    keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n    return key in keys\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.has_value","title":"<code>has_value(value)</code>","text":"<p>Returns True if the value exists, otherwise False.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value of key.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; nt.has_value(10)\nTrue\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if the value exists, otherwise False.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def has_value(self, value: Any) -&gt; bool:\n    \"\"\"Returns True if the value exists, otherwise False.\n\n    Args:\n        value: Value of key.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; nt.has_value(10)\n        True\n\n    Returns:\n        True if the value exists, otherwise False.\n    \"\"\"\n    values = self.values()\n    return value in values\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.items","title":"<code>items()</code>","text":"<p>Return a set-like object providing a view on the NamedTuple's items.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; for key, val in nt.items():\n...     print(f\"Key: {key}, Value: {val}\")\n\"Key: x, Value: 10\"\n\"Key: y, Value: Hello\"\n</code></pre> <p>Returns:</p> Type Description <code>list[tuple[str, Any]]</code> <p>list[tuple[str, Any]]</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def items(self) -&gt; list[tuple[str, Any]]:\n    \"\"\"Return a set-like object providing a view on the NamedTuple's items.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; for key, val in nt.items():\n        ...     print(f\"Key: {key}, Value: {val}\")\n        \"Key: x, Value: 10\"\n        \"Key: y, Value: Hello\"\n\n    Returns:\n        list[tuple[str, Any]]\n    \"\"\"\n    attrs: dict[str, Any] = self.__dict__\n    keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n    return [(key, attrs[key]) for key in keys]\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.keys","title":"<code>keys()</code>","text":"<p>Get a list of keys.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; nt.keys()\n[\"x\", \"y\"]\n</code></pre> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of keys.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def keys(self) -&gt; list[str]:\n    \"\"\"Get a list of keys.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; nt.keys()\n        [\"x\", \"y\"]\n\n    Returns:\n        List of keys.\n    \"\"\"\n    return self._jWjSaNy1RbtQinsN_keys\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to the dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; d = nt.to_dict()\n&gt;&gt;&gt; d[\"x\"]\n10\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with keys and values of the tuple.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert to the dictionary.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; d = nt.to_dict()\n        &gt;&gt;&gt; d[\"x\"]\n        10\n\n    Returns:\n        Dictionary with keys and values of the tuple.\n    \"\"\"\n    attrs: dict[str, Any] = self.__dict__\n    keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n    return {key: attrs[key] for key in keys}\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.update","title":"<code>update(key, value)</code>","text":"<p>Update a value of key.</p> <p>Attention: This is an uncharacteristic action for the type <code>tuple</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name.</p> required <code>value</code> <code>Any</code> <p>Value of key.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; nt.update(\"x\", 20)\n&gt;&gt;&gt; nt.x\n20\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def update(self, key: str, value: Any) -&gt; None:\n    \"\"\"Update a value of key.\n\n    Attention: This is an uncharacteristic action for the type `tuple`.\n\n    Args:\n        key: Key name.\n        value: Value of key.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; nt.update(\"x\", 20)\n        &gt;&gt;&gt; nt.x\n        20\n\n    Returns:\n        None\n    \"\"\"\n    keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n    if key not in keys:\n        err_msg = f\"The key `{key}` is missing!\"\n        raise KeyError(err_msg)\n    self.__dict__[key] = value\n</code></pre>"},{"location":"md_pages/namedtuple/#xloft.namedtuple.NamedTuple.values","title":"<code>values()</code>","text":"<p>Get a list of values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft import NamedTuple\n&gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n&gt;&gt;&gt; nt.values()\n[10, \"Hello\"]\n</code></pre> <p>Returns:</p> Type Description <code>list[Any]</code> <p>List of values.</p> Source code in <code>src\\xloft\\namedtuple.py</code> <pre><code>def values(self) -&gt; list[Any]:\n    \"\"\"Get a list of values.\n\n    Examples:\n        &gt;&gt;&gt; from xloft import NamedTuple\n        &gt;&gt;&gt; nt = NamedTuple(x=10, y=\"Hello\")\n        &gt;&gt;&gt; nt.values()\n        [10, \"Hello\"]\n\n    Returns:\n        List of values.\n    \"\"\"\n    attrs: dict[str, Any] = self.__dict__\n    keys: list[str] = self._jWjSaNy1RbtQinsN_keys\n    return [attrs[key] for key in keys]\n</code></pre>"},{"location":"md_pages/quantum/","title":"Quantum","text":"<p>A set of tools for quantum calculations.</p> <p>A Qubit in a regular computer is quantum of algorithm that is executed in one iteration of a cycle in a separate processor thread.</p> <p>Quantum is a function with an algorithm of task for data processing.</p> <p>In this case, the Qubit is not a single information, but it is a concept of the principle of operation of quantum calculations on a regular computer.</p> <p>The module contains the following tools:</p> <ul> <li><code>LoopMode</code> - Quantum loop mode.</li> <li><code>count_qubits()</code> - Counting the number of conceptual qubits of your computer.</li> <li><code>QuantumLoop</code> - Separation of the cycle into quantum algorithms for multiprocessing data processing.</li> </ul>"},{"location":"md_pages/quantum/#xloft.quantum.LoopMode","title":"<code>LoopMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Quantum loop mode.</p> Source code in <code>src\\xloft\\quantum.py</code> <pre><code>class LoopMode(Enum):\n    \"\"\"Quantum loop mode.\"\"\"\n\n    PROCESS_POOL = 1\n    THREAD_POOL = 2\n</code></pre>"},{"location":"md_pages/quantum/#xloft.quantum.QuantumLoop","title":"<code>QuantumLoop</code>","text":"<p>Separation of the cycle into quantum algorithms for multiprocessing data processing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft.quantum import QuantumLoop\n&gt;&gt;&gt; def task(item):\n... return item * item\n&gt;&gt;&gt; data = range(10)\n&gt;&gt;&gt; QuantumLoop(task, data).run()\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Callable</code> <p>Function with a task algorithm.</p> required <code>data</code> <code>Iterable[Any]</code> <p>The data that needs to be processed.</p> required <code>max_workers</code> <code>int | None</code> <p>The maximum number of processes that can be used to          execute the given calls. If None or not given then as many          worker processes will be created as the machine has processors.</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>The maximum number of seconds to wait. If None, then there      is no limit on the wait time.</p> <code>None</code> <code>chunksize</code> <code>int</code> <p>The size of the chunks the iterable will be broken into        before being passed to a child process. This argument is only        used by ProcessPoolExecutor; it is ignored by ThreadPoolExecutor.</p> <code>1</code> <code>mode</code> <code>LoopMode</code> <p>The operating mode for a quantum loop: LoopMode.PROCESS_POOL | LoopMode.THREAD_POOL.</p> <code>PROCESS_POOL</code> Source code in <code>src\\xloft\\quantum.py</code> <pre><code>class QuantumLoop:\n    \"\"\"Separation of the cycle into quantum algorithms for multiprocessing data processing.\n\n    Examples:\n        &gt;&gt;&gt; from xloft.quantum import QuantumLoop\n        &gt;&gt;&gt; def task(item):\n        ... return item * item\n        &gt;&gt;&gt; data = range(10)\n        &gt;&gt;&gt; QuantumLoop(task, data).run()\n        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n    Args:\n        task: Function with a task algorithm.\n        data: The data that needs to be processed.\n        max_workers: The maximum number of processes that can be used to\n                     execute the given calls. If None or not given then as many\n                     worker processes will be created as the machine has processors.\n        timeout: The maximum number of seconds to wait. If None, then there\n                 is no limit on the wait time.\n        chunksize: The size of the chunks the iterable will be broken into\n                   before being passed to a child process. This argument is only\n                   used by ProcessPoolExecutor; it is ignored by ThreadPoolExecutor.\n        mode: The operating mode for a quantum loop: LoopMode.PROCESS_POOL | LoopMode.THREAD_POOL.\n    \"\"\"\n\n    def __init__(  # noqa: D107\n        self,\n        task: Callable,\n        data: Iterable[Any],\n        max_workers: int | None = None,\n        timeout: float | None = None,\n        chunksize: int = 1,\n        mode: LoopMode = LoopMode.PROCESS_POOL,\n    ) -&gt; None:\n        self.quantum = task\n        self.data = data\n        self.max_workers = max_workers\n        self.timeout = timeout\n        self.chunksize = chunksize\n        self.mode = mode\n\n    def process_pool(self) -&gt; list[Any]:\n        \"\"\"Better suitable for operations for which large processor resources are required.\"\"\"\n        with concurrent.futures.ProcessPoolExecutor(self.max_workers) as executor:\n            results = list(\n                executor.map(\n                    self.quantum,\n                    self.data,\n                    timeout=self.timeout,\n                    chunksize=self.chunksize,\n                ),\n            )\n        return results  # noqa: RET504\n\n    def thread_pool(self) -&gt; list[Any]:\n        \"\"\"More suitable for tasks related to input-output\n        (for example, network queries, file operations),\n        where GIL is freed during input-output operations.\"\"\"  # noqa: D205, D209\n        with concurrent.futures.ThreadPoolExecutor(self.max_workers) as executor:\n            results = list(\n                executor.map(\n                    self.quantum,\n                    self.data,\n                    timeout=self.timeout,\n                    chunksize=self.chunksize,\n                ),\n            )\n        return results  # noqa: RET504\n\n    def run(self) -&gt; list[Any]:\n        \"\"\"Run the quantum loop.\"\"\"\n        results: list[Any] = []\n        match self.mode.value:\n            case 1:\n                results = self.process_pool()\n            case 2:\n                results = self.thread_pool()\n            case _ as unreachable:\n                assert_never(Never(unreachable))\n        return results\n</code></pre>"},{"location":"md_pages/quantum/#xloft.quantum.QuantumLoop.process_pool","title":"<code>process_pool()</code>","text":"<p>Better suitable for operations for which large processor resources are required.</p> Source code in <code>src\\xloft\\quantum.py</code> <pre><code>def process_pool(self) -&gt; list[Any]:\n    \"\"\"Better suitable for operations for which large processor resources are required.\"\"\"\n    with concurrent.futures.ProcessPoolExecutor(self.max_workers) as executor:\n        results = list(\n            executor.map(\n                self.quantum,\n                self.data,\n                timeout=self.timeout,\n                chunksize=self.chunksize,\n            ),\n        )\n    return results  # noqa: RET504\n</code></pre>"},{"location":"md_pages/quantum/#xloft.quantum.QuantumLoop.run","title":"<code>run()</code>","text":"<p>Run the quantum loop.</p> Source code in <code>src\\xloft\\quantum.py</code> <pre><code>def run(self) -&gt; list[Any]:\n    \"\"\"Run the quantum loop.\"\"\"\n    results: list[Any] = []\n    match self.mode.value:\n        case 1:\n            results = self.process_pool()\n        case 2:\n            results = self.thread_pool()\n        case _ as unreachable:\n            assert_never(Never(unreachable))\n    return results\n</code></pre>"},{"location":"md_pages/quantum/#xloft.quantum.QuantumLoop.thread_pool","title":"<code>thread_pool()</code>","text":"<p>More suitable for tasks related to input-output (for example, network queries, file operations), where GIL is freed during input-output operations.</p> Source code in <code>src\\xloft\\quantum.py</code> <pre><code>def thread_pool(self) -&gt; list[Any]:\n    \"\"\"More suitable for tasks related to input-output\n    (for example, network queries, file operations),\n    where GIL is freed during input-output operations.\"\"\"  # noqa: D205, D209\n    with concurrent.futures.ThreadPoolExecutor(self.max_workers) as executor:\n        results = list(\n            executor.map(\n                self.quantum,\n                self.data,\n                timeout=self.timeout,\n                chunksize=self.chunksize,\n            ),\n        )\n    return results  # noqa: RET504\n</code></pre>"},{"location":"md_pages/quantum/#xloft.quantum.count_qubits","title":"<code>count_qubits()</code>","text":"<p>Counting the number of conceptual qubits of your computer.</p> <p>Conceptual qubit is quantum of algorithm (task) that is executed in iterations of a cycle in a separate processor thread.</p> <p>Quantum of algorithm is a function for data processing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from xloft.quantum import count_qubits\n&gt;&gt;&gt; count_qubits()\n16\n</code></pre> <p>Returns:</p> Type Description <code>int</code> <p>The number of conceptual qubits.</p> Source code in <code>src\\xloft\\quantum.py</code> <pre><code>def count_qubits() -&gt; int:\n    \"\"\"Counting the number of conceptual qubits of your computer.\n\n    Conceptual qubit is quantum of algorithm (task) that is executed in\n    iterations of a cycle in a separate processor thread.\n\n    Quantum of algorithm is a function for data processing.\n\n    Examples:\n        &gt;&gt;&gt; from xloft.quantum import count_qubits\n        &gt;&gt;&gt; count_qubits()\n        16\n\n    Returns:\n        The number of conceptual qubits.\n    \"\"\"\n    return multiprocessing.cpu_count()\n</code></pre>"}]}